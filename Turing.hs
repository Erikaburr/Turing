--- Author:  Erik Burr
--- Version: 1.0

------------------------------------------------------------------------------------------------
--------------------------------------- Turing Machine -----------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-------- My Turing machine simply consists on a 'set' of Symbols, States & Transitions. --------
----- Each State is given as a pair of types (Statelabel, [Transition]) listing all ------------
----- possible transitions. There is an infinite tape where the input is given to the ----------
---------------------- machine and it reads off the values and writes to them. -----------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
--------------------------------------- DATA LAYOUT --------------------------------------------
------------------------------------------------------------------------------------------------
type Alphabet = [String]
type Trans    = String
type State    = String
type Symbol   = String
type Turing   = String

data Shift  = Idle   | ShiftLeft | ShiftRight
data Status = Accept | Fail      | Running

data TM = Instruction String InstructionSet String
  deriving (Show, Eq)

data InstructionSet = TapeRight  | TapeLeft
  deriving (Show, Eq)

data Transition = Transition {
  input    :: (State, Symbol),
  output   :: (State, Symbol, Shift)
}

data Tape = Tape {
  left     :: [Symbol],
  current  :: Symbol,
  right    :: [Symbol]
} deriving (Show)

data TuringMachine = TuringMachine {
  trans    :: [Transition],
  curent   :: State,
  tape     :: Tape,
  accept   :: [State],
  stat     :: Status,
  steps    :: Int
}


------------------------------------------------------------------------------------------------
----------------------------------- Higher-Order Functions -------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- Higher-Order functions will take functions as parameters and return 
-- functions as return values.
------------------------------------------------------------------------------------------------
pairs :: Num a => [a] -> [a] -> [a]
pairs = zipWith (+)

applyAll :: [a->b] -> [a] -> [b]
applyAll = zipWith ($)

applyEach :: [a->b] -> a -> [b]
applyEach fs a = map ($a) fs

maxList :: Ord a => [a] -> a
maxList = foldl1 max

lists :: Num a => [[a]] -> a
lists = foldl (+) 0 . map (foldl (+) 0)


------------------------------------------------------------------------------------------------
---------------------------------------- Move Function -----------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- move - This function moves the head of tape 
------------------------------------------------------------------------------------------------
move:: Int -> Bool -> Int
move a b = if b
  then a + 1
  else a - 1


------------------------------------------------------------------------------------------------
---------------------------------------- Halt Function -----------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- halt - This function checks to see if a halt needs to be initiated 
------------------------------------------------------------------------------------------------
halt:: Int -> [Int] -> [Int] -> Bool
halt state accept reject = elem state accept || elem state reject


------------------------------------------------------------------------------------------------
----------------------------------- Format Function --------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- layout - Tape to a string
------------------------------------------------------------------------------------------------
layout :: Tape -> String
layout tm = "\n" ++ "  Post processing:    " ++ show (reverse $ left tm) ++
  "\n  Processing:         [" ++ show [current tm] ++
  "] \n  Future processing:  " ++ show (right tm) ++ "\n"


------------------------------------------------------------------------------------------------
------------------------------------- Duration Function ----------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- duration - This function starts and determines the duration of the program.
------------------------------------------------------------------------------------------------
duration :: TuringMachine -> IO()
duration tm = do
  putStrLn ("--------------------------------- Please select from the following: -------------------------------------")
  putStrLn ("---------------------------------------------------------------------------------------------------------")
  putStrLn ("Enter 'iter' or 'i':   This will iterate through states as the turing machine processes your input file  ") 
  putStrLn ("Enter 'cont' or 'c':   This will go all the steps required to get to the accept state or terminated state") 
  putStrLn ("---------------------------------------------------------------------------------------------------------")
  temp <- getLine
  case temp of
    ('c':'o':'n':'t': []) -> do
      let tempTM = cont tm
      printMachine tempTM
      duration tempTM
    ('c':[]) -> do
      let tempTM = cont tm
      printMachine tempTM
      duration tempTM

    ('i':'t':'e':'r':[]) -> do
      let tempTM = iter tm
      printMachine tempTM
      duration tempTM
    ('i':[]) -> do
      let tempTM = iter tm
      printMachine tempTM
      duration  tempTM

    otherwise -> do
      putStrLn "There is an Error with your input"
      duration tm


------------------------------------------------------------------------------------------------
----------------------------------- Iterate Function -------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- iter - Checks for a valid transition, if so, it is added to the machine and
-- checks to see if its an accept state.
------------------------------------------------------------------------------------------------
iter :: TuringMachine -> TuringMachine
iter (TuringMachine temp stand0 (Tape l syst0 r) as (Running) steps) =
  case find temp (stand0, syst0) of
    Nothing -> TuringMachine temp stand0 (Tape l syst0 r) as Fail (steps + 1)
    Just (stand1, syst1, m) -> if stand1 `elem` as
      then TuringMachine temp stand1 (shiftTape (Tape l syst1 r) m) as Accept (steps + 1)
      else TuringMachine temp stand1 (shiftTape (Tape l syst1 r) m) as Running (steps + 1)
iter tm = tm


------------------------------------------------------------------------------------------------
------------------------------------ Build Function --------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- inputFile - This function attempts to build a machine based on the input file.
------------------------------------------------------------------------------------------------
inputFile :: [String] -> TuringMachine
inputFile xs = TuringMachine (transitions xs) 
  (startState xs) (buildTape xs) (acceptStates xs) Running 0


------------------------------------------------------------------------------------------------
----------------------------------- startState Function ----------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- startState - This function looks for a start State
------------------------------------------------------------------------------------------------
startState :: [String] -> State
startState (('s':'t':'a':'r':'t':':':x):xs) = removeValue x ' '
startState (x:xs) = startState xs
startState [] = error "Failed"


------------------------------------------------------------------------------------------------
----------------------------------- acceptState Function ---------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- acceptStates - This function looks for a list of accept states
------------------------------------------------------------------------------------------------
acceptStates :: [String] -> [State]
acceptStates (('a':'c':'c':'e':'p':'t':':':x):xs) = split (removeValue x ' ') ','
acceptStates (x:xs) = acceptStates xs
acceptStates [] = error "Failed"


------------------------------------------------------------------------------------------------
------------------------------------- buildTape Function ---------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- buildTape - This function looks for a initial value then builds the tape.
------------------------------------------------------------------------------------------------
buildTape :: [String] -> Tape
buildTape (('t':'a':'p':'e':':':x):xs) =
  let symbols = split (removeValue x ' ') ','
  in Tape [] (head symbols) (tail symbols)
buildTape (x:xs) = buildTape xs
buildTape [] = error "Failed"


------------------------------------------------------------------------------------------------
--------------------------------- Continue Function --------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- cont - While the machine has a status of Continue, continue to step on it.
------------------------------------------------------------------------------------------------
cont :: TuringMachine -> TuringMachine
cont tm@(TuringMachine _ _ _ _(Running) _) = cont (iter tm)
cont tm = tm


------------------------------------------------------------------------------------------------
----------------------------------- Transitions Function ---------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- transitions - This function looks for a definition of a transition, and passes it to parse.
------------------------------------------------------------------------------------------------
transitions :: [String] -> [Transition]
transitions (('$':x):xs) = (parse x):(transitions xs)
transitions (x:xs)       = transitions xs
transitions []           = []


------------------------------------------------------------------------------------------------
-------------------------------------- Parse Function ------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- parse - This function defines a transition
------------------------------------------------------------------------------------------------
parse :: String -> Transition
parse str =
  let x = (split (replaceValue (removeList str ['(', ')', ' ']) '=' ',') ',')
  in Transition ((x !! 0), 
  (x !! 1)) ((x !! 2), 
  (x !! 3), 
  (charToShift (head (x !! 4))))


------------------------------------------------------------------------------------------------
----------------------------------- Prefix Function --------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- prefix - this function deals with prefixes.
------------------------------------------------------------------------------------------------
prefix :: Int -> String
prefix i
    | i > 0 = ", "
    | otherwise = ""


------------------------------------------------------------------------------------------------
------------------------------------ Print Function --------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- printMachine - this function prints out the Turing Machine.
------------------------------------------------------------------------------------------------
printMachine :: TuringMachine -> IO()
printMachine (TuringMachine _ st temp _ stat steps) = do
  putStrLn ("---------------------------------------------------------------------------------------------------------")
  putStrLn ("--------------------------------------- Progam File loaded ----------------------------------------------")
  putStrLn ("---------------------------------- Welcome to my Turing Machine -----------------------------------------")
  putStrLn ("---------------------------------------------------------------------------------------------------------")
  putStrLn ("Tape List:            " ++ layout temp)
  putStrLn ("Current State:        " ++ st)
  putStrLn ("Number of Steps:      " ++ (show steps))
  putStrLn ("Current Status:       " ++ (status stat))
  putStrLn ("---------------------------------------------------------------------------------------------------------")
 

------------------------------------------------------------------------------------------------
------------------------------------ Shift Function --------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- charToShift - character to a Shift Object.
------------------------------------------------------------------------------------------------
charToShift :: Char -> Shift
charToShift c
  | c == 'R' = ShiftRight
  | c == 'L' = ShiftLeft
  | otherwise = Idle


------------------------------------------------------------------------------------------------
------------------------------------ Status Function -------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- status - status to a string
------------------------------------------------------------------------------------------------
status :: Status -> String
status (Fail)    = "Trap State"
status (Accept)  = "Accept State"
status _         = "Still Running"


------------------------------------------------------------------------------------------------
------------------------------------- Split Function -------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- split - splits the list
------------------------------------------------------------------------------------------------
split :: Eq a => [a] -> a-> [[a]]
split xs c = foldr (\y acc -> if y == c then []:acc else (y:(head acc)):(tail acc)) [[]] xs


------------------------------------------------------------------------------------------------
----------------------------------- removeValue Function ---------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- removeValue - removes value from list.
------------------------------------------------------------------------------------------------
removeValue :: Eq a => [a] -> a-> [a]
removeValue xs c = foldr (\y acc -> if y == c then acc else y:acc) [] xs


------------------------------------------------------------------------------------------------
----------------------------------- RemoveList Function ----------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- removeList - removes a list
------------------------------------------------------------------------------------------------
removeList :: Eq a => [a] -> [a] -> [a]
removeList str (c:cs) = removeValue (removeList str cs) c
removeList str [] = str


------------------------------------------------------------------------------------------------
------------------------------------ Status Function -------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- replaceValue - replaces a value in a list with another
------------------------------------------------------------------------------------------------
replaceValue :: Eq a => [a] -> a -> a -> [a]
replaceValue (x:xs) y0 y1 = if x == y0 
  then y1:(replaceValue xs y0 y1) 
  else x:(replaceValue xs y0 y1)
replaceValue [] _ _ = []


------------------------------------------------------------------------------------------------
---------------------------------- shiftTape Function ------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- shiftTape - Shifts the tape
------------------------------------------------------------------------------------------------
shiftTape :: Tape -> Shift -> Tape
shiftTape (Tape l sy (r:rs))  ShiftRight = Tape (sy:l) r rs
shiftTape (Tape l sy [])      ShiftRight = Tape (sy:l) "_" []
shiftTape (Tape (l:ls) sy r)  ShiftLeft  = Tape ls l (sy:r)
shiftTape (Tape [] sy r)      ShiftLeft  = Tape [] "_" (sy:r)
shiftTape ta _ = ta


------------------------------------------------------------------------------------------------
------------------------------------- Find Function --------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- find - Looks for a list and goes through the list and returns the approprate value
------------------------------------------------------------------------------------------------
find :: [Transition] -> (State, Symbol) -> Maybe (State, Symbol, Shift)
find ((Transition input output):temp1) temp
  | input == temp = Just output
  | otherwise     = find temp1 temp
find [] temp      = Nothing


------------------------------------------------------------------------------------------------
------------------------------------- Main Function --------------------------------------------
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
-- main - Builds the program, then asks the user for an input file
------------------------------------------------------------------------------------------------
main :: IO()
main = do
  putStrLn "Welcome to my Turing Machine!"
  putStrLn "Please input a filename to begin (.txt):"
  fileName      <- getLine
  fileContents  <- readFile fileName
  let fileLines = lines fileContents
  let myTM      = inputFile fileLines
  printMachine myTM
  duration myTM
